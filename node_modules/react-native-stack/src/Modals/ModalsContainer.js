import React, { createElement, isValidElement, memo, useEffect, useState } from 'react';
import { useApp } from '../App/useApp';
import { RouterAction, RouterEventType } from '../Router';
import { findMatchingRoutes } from '../Router/utils';
import { ModalProvider } from './ModalContext';
import { ModalLifecycleProvider } from './ModalLifecycleContext';
import { diffLocationKeys } from './utils';
const Component = memo(({ Component }) => {
    if (Component && isValidElement(Component)) {
        return Component;
    }
    else if (Component) {
        return createElement(Component);
    }
    return null;
});
export const ModalsContainer = ({ modals }) => {
    const app = useApp();
    const [matchingRoutes, setMatchingRoutes] = useState(() => findMatchingRoutes(app.modals.entries, modals));
    const [closingModals, setClosingModals] = useState({});
    useEffect(() => {
        return app.modals.addEventListener(RouterEventType.LocationChange, ({ action, entries }) => {
            if (action === RouterAction.RESET) {
                setClosingModals({
                    ...closingModals,
                    ...diffLocationKeys(entries, matchingRoutes.map(i => i.location))
                });
            }
            else {
                setMatchingRoutes(findMatchingRoutes(entries, modals));
            }
        });
    }, [closingModals, matchingRoutes]); // Note: this causes the listener to unregister/register on every closingModals and matchingRoutes changes, no alternative yet using hooks, but the react team promises something is in the work
    return (<>
      {matchingRoutes.map(matchingRoute => (<ModalLifecycleProvider key={matchingRoute.location.key} willBlur={!!closingModals[matchingRoute.location.key]}>
          <ModalProvider location={matchingRoute.location} match={matchingRoute.match} route={matchingRoute.route}>
            <Component Component={matchingRoute.route.Component}/>
          </ModalProvider>
        </ModalLifecycleProvider>))}
    </>);
};
