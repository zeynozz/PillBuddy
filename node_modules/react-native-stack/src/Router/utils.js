/**
 * MIT License
 *
 * Copyright (c) React Training 2016-2018
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import pathToRegexp from 'path-to-regexp';
const cache = {};
const cacheLimit = 10000;
let cacheCount = 0;
function compilePath(path) {
    if (cache[path])
        return cache[path];
    const keys = [];
    const regexp = pathToRegexp(path, keys);
    const result = { regexp, keys };
    if (cacheCount < cacheLimit) {
        cache[path] = result;
        cacheCount++;
    }
    return result;
}
/**
 * Public API for matching a URL pathname to a path.
 */
export function matchPath(pathname, options) {
    if (typeof options === 'string')
        options = { path: options };
    const { path } = options;
    const paths = [].concat(path);
    return paths.reduce((matched, path) => {
        if (matched)
            return matched;
        const { regexp, keys } = compilePath(path);
        const match = regexp.exec(pathname);
        if (!match)
            return null;
        return {
            params: keys.reduce((memo, key, index) => {
                memo[key.name] = match[index + 1];
                return memo;
            }, {}),
            path // the path used to match
        };
    }, null);
}
export function findMatchingRoute(location, routes, index) {
    let match;
    const matchingRoute = routes.find((route) => {
        const result = matchPath(location.pathname, route);
        if (result) {
            match = result;
            return true;
        }
        return false;
    });
    if (match && matchingRoute) {
        return {
            index,
            location,
            match,
            route: matchingRoute
        };
    }
    return null;
}
export function findMatchingRoutes(entries, routes, prevMatchingRoutes) {
    const prevRoutesMap = {};
    if (prevMatchingRoutes && prevMatchingRoutes.length) {
        for (const item of prevMatchingRoutes) {
            prevRoutesMap[item.location.key] = item;
        }
    }
    return entries
        .map((location, index) => {
        if (prevRoutesMap[location.key] !== undefined) {
            return {
                ...prevRoutesMap[location.key],
                index,
                location
            };
        }
        return findMatchingRoute(location, routes, index);
    })
        .filter(item => !!(item && item.match));
}
