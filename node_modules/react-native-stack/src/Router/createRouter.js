/**
 * MIT License
 *
 * Copyright (c) React Training 2016-2018
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import warning from 'tiny-warning';
import { RouterAction, RouterEventType } from '.';
import { createLocation } from './createLocation';
import { createTransitionManager } from './createTransitionManager';
function clamp(n, lowerBound, upperBound) {
    return Math.min(Math.max(n, lowerBound), upperBound);
}
export const createRouter = (options = {}) => {
    const { getUserConfirmation, initialEntries = [], initialIndex = -1, keyLength = 6 } = options;
    const transitionManager = createTransitionManager();
    function updateRouter(nextRouter) {
        Object.assign(router, nextRouter);
        router.length = router.entries.length;
        notifyListeners(RouterEventType.LocationChange, {
            action: router.action,
            entries: router.entries,
            index: router.index,
            length: router.length,
            location: router.location,
            type: RouterEventType.LocationChange
        });
    }
    function createKey() {
        return Math.random()
            .toString(36)
            .substr(2, keyLength);
    }
    const index = clamp(initialIndex, 0, initialEntries.length - 1);
    const entries = initialEntries.map(entry => createLocation(entry, entry.state, entry.key || createKey()));
    function push(path, state) {
        warning(!(typeof path === 'object' &&
            path.state !== undefined &&
            state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' +
            'argument is a location-like object that already has state; it is ignored');
        state = typeof path === 'object' ? path.state : state;
        path = typeof path === 'object' ? path.pathname : path;
        const action = 'PUSH';
        const location = createLocation(path, state, createKey());
        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, ok => {
            if (!ok)
                return;
            const prevIndex = router.index;
            const nextIndex = prevIndex + 1;
            const nextEntries = router.entries.slice(0);
            if (nextEntries.length > nextIndex) {
                nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
            }
            else {
                nextEntries.push(location);
            }
            updateRouter({
                action,
                entries: nextEntries,
                index: nextIndex,
                location
            });
        });
    }
    function replace(path, state) {
        warning(!(typeof path === 'object' &&
            path.state !== undefined &&
            state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' +
            'argument is a location-like object that already has state; it is ignored');
        state = typeof path === 'object' ? path.state : state;
        path = typeof path === 'object' ? path.pathname : path;
        const action = 'REPLACE';
        const location = createLocation(path, state, createKey());
        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, ok => {
            if (!ok)
                return;
            router.entries[router.index] = location;
            updateRouter({ action, location });
        });
    }
    function reset(entries, index = 0) {
        const action = 'RESET';
        const len = entries.length;
        const finalEntries = [];
        for (let i = 0; i < len; ++i) {
            finalEntries.push(createLocation(entries[i].pathname, entries[i].state, entries[i].key || createKey()));
        }
        transitionManager.confirmTransitionTo(finalEntries[index], action, getUserConfirmation, ok => {
            if (!ok) {
                return;
            }
            ;
            router.entries = finalEntries;
            updateRouter({ action, location: finalEntries[index], index });
        });
    }
    function go(n) {
        const nextIndex = clamp(router.index + n, 0, router.entries.length - 1);
        const action = 'POP';
        const location = router.entries[nextIndex];
        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, ok => {
            if (ok) {
                updateRouter({
                    action,
                    index: nextIndex,
                    location
                });
            }
            else {
                // Mimic the behavior of DOM histories by
                // causing a render after a cancelled POP.
                updateRouter(null);
            }
        });
    }
    function goBack() {
        go(-1);
    }
    function goForward() {
        go(1);
    }
    function setLocationState(key, state) {
        const index = router.entries.findIndex(entry => entry.key === key);
        if (index !== -1) {
            ;
            router.entries = [
                ...router.entries.slice(0, index),
                { ...router.entries[index], state },
                ...router.entries.slice(index + 1)
            ];
            router.length = router.entries.length;
            notifyListeners(RouterEventType.LocationStateChange, {
                key,
                state,
                type: RouterEventType.LocationStateChange
            });
        }
    }
    function canGo(n) {
        const nextIndex = router.index + n;
        return nextIndex >= 0 && nextIndex < router.entries.length;
    }
    function block(prompt = false) {
        return transitionManager.setPrompt(prompt);
    }
    let listerners = [];
    function addEventListener(type, handler) {
        listerners.push({
            handler: handler || type,
            type: handler ? type : undefined
        });
        return () => {
            if (type) {
                removeEventListener(type, handler);
            }
            else
                removeEventListener(handler);
        };
    }
    function removeEventListener(type, handler) {
        const e = handler
            ? type
            : undefined;
        handler = handler || type;
        listerners = listerners.filter(l => {
            if (e) {
                return l.type === e && l.handler === handler;
            }
            return l.handler === handler;
        });
    }
    function notifyListeners(type, event) {
        listerners.forEach(({ type: t, handler }) => {
            if (!t || t === type)
                handler(event);
        });
    }
    const router = {
        action: RouterAction.POP,
        addEventListener,
        block,
        canGo,
        entries,
        go,
        goBack,
        goForward,
        index,
        length: entries.length,
        location: entries[index],
        push,
        removeEventListener,
        replace,
        reset,
        setLocationState
    };
    return router;
};
