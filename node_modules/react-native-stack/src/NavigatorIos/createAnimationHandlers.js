import { State as GestureState } from 'react-native-gesture-handler';
import Animated from 'react-native-reanimated';
const { set, cond, startClock, clockRunning, stopClock, block, event, eq, multiply, sub, and, min, max, neq, lessThan, greaterThan, lessOrEq, divide, spring, call, Value, or, Clock, add } = Animated;
export function createAnimationHandlers(router, isRTLValue) {
    const navigate = new Value(-1);
    const currentIndex = new Value(router.index);
    const nextIndex = new Value(router.index);
    const translationX = new Value(0);
    const width = new Value(0);
    const isRTL = new Value(isRTLValue ? 1 : 0);
    // Position
    const position = max(add(currentIndex, cond(width, divide(translationX, width), 0)), 0);
    // Gesture Values
    const gestureTranslationX = new Value(0);
    const gestureVelocityX = new Value(0);
    const prevGestureTranslationX = new Value(0);
    const gestureTransitionClock = new Clock();
    // Navigate Values
    const navigateTransitionClock = new Clock();
    const wasNavigateTransitionClockRuning = new Value(0);
    // Create Gesture Handlers
    function createGestureHandlers() {
        const springState = {
            finished: new Value(0),
            position: translationX,
            time: new Value(0),
            velocity: new Value(0)
        };
        const backGestureState = new Value(-1);
        const forwardGestureState = new Value(-1);
        const beganGesture = new Value(0);
        // Gesture Event Handler
        function createGestureEventHandler(state) {
            return event([
                {
                    nativeEvent: {
                        state,
                        translationX: gestureTranslationX,
                        velocityX: gestureVelocityX
                    }
                }
            ]);
        }
        // Back Gesture Handler
        function createBackGestureHandler() {
            return block([
                // Back gesture began
                cond(eq(backGestureState, GestureState.BEGAN), cond(greaterThan(currentIndex, 0), [
                    set(wasNavigateTransitionClockRuning, clockRunning(navigateTransitionClock)),
                    stopClock(gestureTransitionClock),
                    stopClock(navigateTransitionClock),
                    cond(neq(navigate, -1), [
                        set(nextIndex, navigate),
                        set(currentIndex, navigate),
                        set(navigate, -1),
                        set(translationX, 0)
                    ], cond(and(neq(currentIndex, nextIndex), wasNavigateTransitionClockRuning), [set(currentIndex, nextIndex), set(translationX, 0)])),
                    set(prevGestureTranslationX, 0),
                    set(nextIndex, sub(currentIndex, 1)),
                    set(beganGesture, 1)
                ])),
                // Back gesture drag
                cond(eq(backGestureState, GestureState.ACTIVE), cond(greaterThan(currentIndex, 0), [
                    set(beganGesture, 1),
                    set(translationX, max(min(cond(isRTL, add(translationX, sub(gestureTranslationX, prevGestureTranslationX)), sub(translationX, sub(gestureTranslationX, prevGestureTranslationX))), 0), multiply(width, -1))),
                    set(prevGestureTranslationX, gestureTranslationX)
                ])),
                // Back gestgure end
                cond(eq(backGestureState, GestureState.END), cond(greaterThan(currentIndex, 0), [
                    cond(or(clockRunning(navigateTransitionClock), eq(beganGesture, 0)), 0, [
                        cond(lessThan(cond(isRTL, multiply(gestureVelocityX, -1), gestureVelocityX), -50), 
                        // Reset if velocity is less than -50
                        createResetSpring(), cond(greaterThan(cond(isRTL, multiply(gestureVelocityX, -1), gestureVelocityX), 50), 
                        // Go back if velocity is more than 50
                        createGoBackSpring(), cond(lessOrEq(multiply(translationX, -1), divide(width, 3)), 
                        // Reset if not 1/3 of the way in
                        createResetSpring(), 
                        // Go back if more than 1/3 of the way in
                        createGoBackSpring())))
                    ])
                ]))
            ]);
        }
        // Reset after drag spring
        function createResetSpring() {
            return cond(clockRunning(gestureTransitionClock), [
                spring(gestureTransitionClock, springState, {
                    damping: 100,
                    mass: 3,
                    overshootClamping: true,
                    restDisplacementThreshold: 0.01,
                    restSpeedThreshold: 0.01,
                    stiffness: 6000,
                    toValue: 0
                }),
                cond(springState.finished, [
                    stopClock(gestureTransitionClock),
                    set(beganGesture, 0),
                    set(nextIndex, currentIndex),
                    cond(neq(navigate, -1), [
                        call([navigate], ([value]) => {
                            navigate.setValue(value);
                        })
                    ])
                ])
            ], [
                set(springState.finished, 0),
                set(springState.time, 0),
                set(springState.velocity, 0),
                startClock(gestureTransitionClock)
            ]);
        }
        // Go back after drag spring
        function createGoBackSpring() {
            return cond(clockRunning(gestureTransitionClock), [
                spring(gestureTransitionClock, springState, {
                    damping: 300,
                    mass: 3,
                    overshootClamping: true,
                    restDisplacementThreshold: 0.01,
                    restSpeedThreshold: 0.01,
                    stiffness: 7000,
                    toValue: multiply(width, -1)
                }),
                cond(springState.finished, [
                    stopClock(gestureTransitionClock),
                    set(beganGesture, 0),
                    set(currentIndex, nextIndex),
                    set(translationX, 0),
                    call([], () => {
                        router.goBack();
                    }),
                    cond(neq(navigate, -1), [
                        call([navigate], ([value]) => {
                            navigate.setValue(value);
                        })
                    ])
                ])
            ], [
                set(springState.finished, 0),
                set(springState.time, 0),
                set(springState.velocity, 0),
                startClock(gestureTransitionClock)
            ]);
        }
        return {
            handleBackGesture: createBackGestureHandler(),
            handleBackGestureEvent: createGestureEventHandler(backGestureState),
            handleForwardGestureEvent: createGestureEventHandler(forwardGestureState)
        };
    }
    function createNavigationTransitionHandlers() {
        const state = {
            finished: new Value(0),
            position: translationX,
            time: new Value(0),
            velocity: new Value(0)
        };
        // Transition To Start
        function createNavigateTransitionStartHandler() {
            const navigateTransitionPositionX = new Value(0);
            return cond(or(neq(navigate, -1), clockRunning(navigateTransitionClock)), [
                cond(and(neq(navigate, -1), eq(clockRunning(navigateTransitionClock), 0)), [set(nextIndex, navigate), set(navigate, -1)]),
                cond(clockRunning(navigateTransitionClock), 
                // Run animation
                [
                    set(navigateTransitionPositionX, cond(lessThan(nextIndex, currentIndex), multiply(width, multiply(sub(currentIndex, nextIndex), -1)), multiply(width, sub(nextIndex, currentIndex)))),
                    spring(navigateTransitionClock, state, {
                        damping: 500,
                        mass: 3,
                        overshootClamping: true,
                        restDisplacementThreshold: 0.01,
                        restSpeedThreshold: 0.01,
                        stiffness: 1000,
                        toValue: navigateTransitionPositionX
                    }),
                    cond(state.finished, [
                        stopClock(navigateTransitionClock),
                        set(currentIndex, nextIndex),
                        set(translationX, 0),
                        cond(neq(navigate, -1), [
                            call([navigate], ([value]) => {
                                navigate.setValue(value);
                            })
                        ])
                    ])
                ], 
                // Start animation
                [
                    set(prevGestureTranslationX, 0),
                    set(state.finished, 0),
                    set(state.time, 0),
                    set(state.velocity, 0),
                    cond(clockRunning(gestureTransitionClock), stopClock(gestureTransitionClock)),
                    startClock(navigateTransitionClock)
                ])
            ]);
        }
        return {
            handleNavigateTransitionStart: createNavigateTransitionStartHandler()
        };
    }
    return {
        ...createGestureHandlers(),
        ...createNavigationTransitionHandlers(),
        currentIndex,
        isRTL,
        navigate,
        nextIndex,
        position,
        width
    };
}
