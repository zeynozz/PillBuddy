import React, { createElement, isValidElement, memo, useMemo } from 'react';
import { StyleSheet, View } from 'react-native';
import Animated from 'react-native-reanimated';
import { NativeScreen } from 'react-native-screens';
import { LocationProvider } from '../Router/LocationContext';
const { cond, add, eq, or, multiply, sub, interpolate, Extrapolate, min, max, block, createAnimatedComponent } = Animated;
export const RNSScreen = createAnimatedComponent(NativeScreen);
const Shadow = ({ position, index, currentIndex, nextIndex }) => (<Animated.View style={[
    styles.shadow,
    {
        opacity: cond(or(eq(index, currentIndex), eq(index, nextIndex)), interpolate(position, {
            extrapolate: Extrapolate.CLAMP,
            inputRange: [
                min(min(nextIndex, sub(index, 1)), currentIndex),
                index,
                max(max(nextIndex, add(index, 1)), currentIndex)
            ],
            outputRange: [0, 1, 1]
        }), 0)
    }
]}/>);
const Backdrop = ({ children }) => (<View style={styles.backdrop} children={children}/>);
const Component = memo(({ Component }) => {
    if (Component && isValidElement(Component)) {
        return Component;
    }
    else if (Component) {
        return createElement(Component);
    }
    return null;
});
export const Screen = ({ location, match, route, index, animationHandlers: { currentIndex, nextIndex, position, width, isRTL } }) => {
    const { active, innerOpacity, translateX } = useMemo(() => {
        const innerOpacity = interpolate(position, {
            extrapolate: Extrapolate.CLAMP,
            inputRange: [
                min(min(nextIndex, sub(index, 1)), currentIndex),
                index,
                max(max(nextIndex, add(index, 1)), currentIndex)
            ],
            outputRange: [1, 1, 0.9]
        });
        const translateX = interpolate(position, {
            extrapolate: Extrapolate.CLAMP,
            inputRange: [
                min(min(nextIndex, sub(index, 1)), currentIndex),
                index,
                max(max(nextIndex, add(index, 1)), currentIndex)
            ],
            outputRange: [
                cond(isRTL, multiply(width, -1), width),
                0,
                cond(isRTL, multiply(width, 0.333), multiply(width, -0.333))
            ]
        });
        const active = block([
            position,
            cond(or(eq(currentIndex, index), eq(nextIndex, index)), 1, 0)
        ]);
        return {
            active,
            innerOpacity,
            translateX
        };
    }, []);
    const style = {
        transform: [{ translateX }],
        zIndex: index
    };
    return (<RNSScreen active={active} key={location.key} style={[styles.container, style]}>
      <LocationProvider location={location} key={location.key} match={match} route={route}>
        <Shadow position={position} index={index} currentIndex={currentIndex} nextIndex={nextIndex}/>
        <Backdrop>
          <Animated.View style={[styles.innerContainer, { opacity: innerOpacity }]}>
            <Component Component={route.Component}/>
          </Animated.View>
        </Backdrop>
      </LocationProvider>
    </RNSScreen>);
};
const styles = StyleSheet.create({
    rnsScreen: {
        bottom: 0,
        flex: 1,
        left: 0,
        position: 'absolute',
        right: 0,
        top: 0
    },
    container: {
        bottom: 0,
        left: 0,
        position: 'absolute',
        right: 0,
        top: 0
    },
    shadow: {
        backgroundColor: 'white',
        bottom: -100,
        left: 0,
        position: 'absolute',
        right: 0,
        shadowColor: 'rgb(56, 45, 59)',
        shadowOffset: { width: 0, height: 0 },
        shadowOpacity: 0.56,
        shadowRadius: 10,
        top: -100
    },
    backdrop: {
        backgroundColor: '#1F0D29',
        bottom: 0,
        left: 0,
        position: 'absolute',
        right: 0,
        top: 0
    },
    innerContainer: {
        backgroundColor: 'white',
        flex: 1
    }
});
