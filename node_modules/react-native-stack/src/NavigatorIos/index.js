import React, { useEffect, useLayoutEffect, useMemo, useRef, useState } from 'react';
import { Dimensions, I18nManager, StyleSheet, View } from 'react-native';
import { PanGestureHandler } from 'react-native-gesture-handler';
import Animated from 'react-native-reanimated';
import { ScreenContainer, useScreens } from 'react-native-screens';
import { RouterAction, RouterEventType } from '../Router';
import { RouterProvider } from '../Router/RouterContext';
import { createAnimationHandlers } from './createAnimationHandlers';
import { NavigationBarIos } from './NavigationBar';
import { NavigationBarBackgroundIos } from './NavigationBar/NavigationBarBackgroundIos';
import { Screen } from './Screen';
import { findMatchingRoutes } from './utils/findMatchingRoutes';
import { measure } from './utils/measure';
import { shouldUpdateRoutes } from './utils/shouldUpdateRoutes';
useScreens();
const GESTURE_RESPONSE_DISTANCE_HORIZONTAL = 50;
export const NavigatorIos = ({ router, routes, navigationBar, backGestureEnabled, forwardGestureEnabled, isRTL }) => {
    const element = useRef(null);
    const [matchingRoutes, setMatchingRoutes] = useState(() => findMatchingRoutes(router, routes, undefined, !!forwardGestureEnabled));
    const animationHandlers = useMemo(() => createAnimationHandlers(router, !!isRTL), []);
    useEffect(() => {
        return router.addEventListener(RouterEventType.LocationChange, ({ action, index, entries }) => {
            if (action !== RouterAction.RESET) {
                animationHandlers.navigate.setValue(index);
                if (shouldUpdateRoutes(matchingRoutes, entries)) {
                    setMatchingRoutes(findMatchingRoutes(router, routes, matchingRoutes, !!forwardGestureEnabled));
                }
            }
            else {
                animationHandlers.navigate.setValue(-1);
                animationHandlers.currentIndex.setValue(index);
                animationHandlers.nextIndex.setValue(index);
                setMatchingRoutes(findMatchingRoutes(router, routes, matchingRoutes, !!forwardGestureEnabled));
            }
        });
    }, [matchingRoutes]); // Note: this causes the listener to unregister/register on every matchingRoutes changes, no alternative yet using hooks, but the react team promises something is in the work
    useEffect(() => {
        const handler = () => {
            measure(element, animationHandlers.width);
        };
        Dimensions.addEventListener('change', handler);
        return () => {
            Dimensions.removeEventListener('change', handler);
        };
    }, []);
    useLayoutEffect(() => {
        measure(element, animationHandlers.width);
    });
    let content = (<ScreenContainer style={styles.screensContainer}>
      {matchingRoutes.map(({ route, location, indexValue, match }) => (<Screen key={location.key} location={location} match={match} route={route} index={indexValue} animationHandlers={animationHandlers}/>))}
    </ScreenContainer>);
    if (forwardGestureEnabled) {
        content = (<PanGestureHandler activeOffsetX={isRTL ? 5 : -5} failOffsetY={[-20, 20]} hitSlop={isRTL
            ? {
                left: 0,
                width: GESTURE_RESPONSE_DISTANCE_HORIZONTAL
            }
            : {
                right: 0,
                width: GESTURE_RESPONSE_DISTANCE_HORIZONTAL
            }} onGestureEvent={animationHandlers.handleForwardGestureEvent} onHandlerStateChange={animationHandlers.handleForwardGestureEvent}>
        <Animated.View style={styles.animatedView}>{content}</Animated.View>
      </PanGestureHandler>);
    }
    if (backGestureEnabled) {
        content = (<PanGestureHandler activeOffsetX={isRTL ? -5 : 5} failOffsetY={[-20, 20]} hitSlop={isRTL
            ? {
                right: 0,
                width: GESTURE_RESPONSE_DISTANCE_HORIZONTAL
            }
            : {
                left: 0,
                width: GESTURE_RESPONSE_DISTANCE_HORIZONTAL
            }} onGestureEvent={animationHandlers.handleBackGestureEvent} onHandlerStateChange={animationHandlers.handleBackGestureEvent}>
        <Animated.View style={styles.animatedView}>{content}</Animated.View>
      </PanGestureHandler>);
    }
    return (<RouterProvider router={router}>
      <View style={styles.container} ref={element}>
        {content}
      </View>

      {navigationBar && navigationBar.BackgroundComponent ? (<NavigationBarBackgroundIos navigationBar={navigationBar} router={router}/>) : null}
      {navigationBar && navigationBar.Component ? (<NavigationBarIos navigationBar={navigationBar}/>) : null}

      <Animated.Code exec={animationHandlers.handleNavigateTransitionStart}/>
      <Animated.Code exec={animationHandlers.handleBackGesture}/>
    </RouterProvider>);
};
NavigatorIos.defaultProps = {
    backGestureEnabled: true,
    forwardGestureEnabled: false,
    isRTL: I18nManager.isRTL
};
const styles = StyleSheet.create({
    container: {
        flex: 1,
        overflow: 'hidden'
    },
    screensContainer: {
        flex: 1
    },
    animatedView: { flex: 1 },
    rnsScreen: {
        bottom: 0,
        flex: 1,
        left: 0,
        position: 'absolute',
        right: 0,
        top: 0
    }
});
